{"ast":null,"code":"export default {\n  models: 'hands',\n  tags: ['browser'],\n  enabled: false,\n  // Number of frames the current element is the same as the last\n  numFramesFocused: [0, 0, 0, 0],\n  // The current scrollable target\n  $target: [null, null, null, null],\n  // The original grab point\n  origScrollLeft: [0, 0, 0, 0],\n  origScrollTop: [0, 0, 0, 0],\n  // The tweened scrollTop, used to smoothen out scroll\n  tweenScroll: [{\n    x: 0,\n    y: 0\n  }, {\n    x: 0,\n    y: 0\n  }, {\n    x: 0,\n    y: 0\n  }, {\n    x: 0,\n    y: 0\n  }],\n  config: {\n    // Number of frames over the same element before activating that element\n    framesToFocus: 10,\n    // Number of pixels the middle and thumb tips must be near each other to drag\n    threshold: 50,\n    // Number of frames where a hold is not registered before releasing a drag\n    numThresholdErrorFrames: 5,\n    // Speed multiplier\n    speed: 1\n  },\n\n  /**\n   * Scroll the page when the cursor goes above/below the threshold\n   */\n  onFrame({\n    hands\n  }) {\n    // Wait for other plugins to update\n    setTimeout(() => {\n      if (!hands.pointer) return;\n      const height = this.handsfree.debug.$canvas.hands.height;\n      const width = this.handsfree.debug.$canvas.hands.width;\n      hands.pointer.forEach((pointer, n) => {\n        var _hands$pinchState$n, _hands$pinchState$n2;\n\n        // @fixme Get rid of n > origPinch.length\n        if (!pointer.isVisible || n > hands.origPinch.length) return; // Start scroll\n\n        if (((_hands$pinchState$n = hands.pinchState[n]) === null || _hands$pinchState$n === void 0 ? void 0 : _hands$pinchState$n[0]) === 'start') {\n          let $potTarget = document.elementFromPoint(pointer.x, pointer.y);\n          this.$target[n] = this.getTarget($potTarget);\n          this.tweenScroll[n].x = this.origScrollLeft[n] = this.getTargetScrollLeft(this.$target[n]);\n          this.tweenScroll[n].y = this.origScrollTop[n] = this.getTargetScrollTop(this.$target[n]);\n          this.handsfree.TweenMax.killTweensOf(this.tweenScroll[n]);\n        }\n\n        if (((_hands$pinchState$n2 = hands.pinchState[n]) === null || _hands$pinchState$n2 === void 0 ? void 0 : _hands$pinchState$n2[0]) === 'held' && this.$target[n]) {\n          // With this one you have to pinch, drag, and release in sections each time\n          // this.handsfree.TweenMax.to(this.tweenScroll[n], 1, {\n          //   x: this.origScrollLeft[n] - (hands.origPinch[n][0].x - hands.curPinch[n][0].x) * width,\n          //   y: this.origScrollTop[n] + (hands.origPinch[n][0].y - hands.curPinch[n][0].y) * height,\n          //   overwrite: true,\n          //   ease: 'linear.easeNone',\n          //   immediateRender: true  \n          // })\n          // With this one it continuously moves based on the pinch drag distance\n          this.handsfree.TweenMax.to(this.tweenScroll[n], 1, {\n            x: this.tweenScroll[n].x - (hands.origPinch[n][0].x - hands.curPinch[n][0].x) * width * this.config.speed,\n            y: this.tweenScroll[n].y + (hands.origPinch[n][0].y - hands.curPinch[n][0].y) * height * this.config.speed,\n            overwrite: true,\n            ease: 'linear.easeNone',\n            immediateRender: true\n          });\n          this.$target[n].scrollTo(this.tweenScroll[n].x, this.tweenScroll[n].y);\n        }\n      });\n    });\n  },\n\n  /**\n   * Finds the closest scroll area\n   */\n  getTarget($potTarget) {\n    const styles = $potTarget && $potTarget.getBoundingClientRect ? getComputedStyle($potTarget) : {};\n\n    if ($potTarget && $potTarget.scrollHeight > $potTarget.clientHeight && (styles.overflow === 'auto' || styles.overflow === 'auto scroll' || styles.overflowY === 'auto' || styles.overflowY === 'auto scroll')) {\n      return $potTarget;\n    } else {\n      if ($potTarget && $potTarget.parentElement) {\n        return this.getTarget($potTarget.parentElement);\n      } else {\n        return window;\n      }\n    }\n  },\n\n  /**\n   * Gets the scrolltop, taking account the window object\n   */\n  getTargetScrollLeft($target) {\n    return $target.scrollX || $target.scrollLeft || 0;\n  },\n\n  /**\n   * Gets the scrolltop, taking account the window object\n   */\n  getTargetScrollTop($target) {\n    return $target.scrollY || $target.scrollTop || 0;\n  }\n\n};","map":{"version":3,"sources":["/Users/dakshendrasingh/Documents/GitHub/kamyab_web/src/Handsfree.js"],"names":["models","tags","enabled","numFramesFocused","$target","origScrollLeft","origScrollTop","tweenScroll","x","y","config","framesToFocus","threshold","numThresholdErrorFrames","speed","onFrame","hands","setTimeout","pointer","height","handsfree","debug","$canvas","width","forEach","n","isVisible","origPinch","length","pinchState","$potTarget","document","elementFromPoint","getTarget","getTargetScrollLeft","getTargetScrollTop","TweenMax","killTweensOf","to","curPinch","overwrite","ease","immediateRender","scrollTo","styles","getBoundingClientRect","getComputedStyle","scrollHeight","clientHeight","overflow","overflowY","parentElement","window","scrollX","scrollLeft","scrollY","scrollTop"],"mappings":"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","sourcesContent":["export default {\n  models: 'hands',\n  tags: ['browser'],\n  enabled: false,\n\n  // Number of frames the current element is the same as the last\n  numFramesFocused: [0, 0, 0, 0],\n  // The current scrollable target\n  $target: [null, null, null, null],\n\n  // The original grab point\n  origScrollLeft: [0, 0, 0, 0],\n  origScrollTop: [0, 0, 0, 0],\n\n  // The tweened scrollTop, used to smoothen out scroll\n  tweenScroll: [{x: 0, y: 0}, {x: 0, y: 0}, {x: 0, y: 0}, {x: 0, y: 0}],\n\n  config: {\n    // Number of frames over the same element before activating that element\n    framesToFocus: 10,\n\n    // Number of pixels the middle and thumb tips must be near each other to drag\n    threshold: 50,\n\n    // Number of frames where a hold is not registered before releasing a drag\n    numThresholdErrorFrames: 5,\n\n    // Speed multiplier\n    speed: 1\n  },\n\n  /**\n   * Scroll the page when the cursor goes above/below the threshold\n   */\n  onFrame ({hands}) {\n    // Wait for other plugins to update\n    setTimeout(() => {\n      if (!hands.pointer) return\n      const height = this.handsfree.debug.$canvas.hands.height\n      const width = this.handsfree.debug.$canvas.hands.width\n\n      hands.pointer.forEach((pointer, n) => {\n        // @fixme Get rid of n > origPinch.length\n        if (!pointer.isVisible || n > hands.origPinch.length) return\n\n        // Start scroll\n        if (hands.pinchState[n]?.[0] === 'start') {\n          let $potTarget = document.elementFromPoint(pointer.x, pointer.y)\n\n          this.$target[n] = this.getTarget($potTarget)\n          this.tweenScroll[n].x = this.origScrollLeft[n] = this.getTargetScrollLeft(this.$target[n])\n          this.tweenScroll[n].y = this.origScrollTop[n] = this.getTargetScrollTop(this.$target[n])\n          this.handsfree.TweenMax.killTweensOf(this.tweenScroll[n])\n        }\n\n        if (hands.pinchState[n]?.[0] === 'held' && this.$target[n]) {\n          // With this one you have to pinch, drag, and release in sections each time\n          // this.handsfree.TweenMax.to(this.tweenScroll[n], 1, {\n          //   x: this.origScrollLeft[n] - (hands.origPinch[n][0].x - hands.curPinch[n][0].x) * width,\n          //   y: this.origScrollTop[n] + (hands.origPinch[n][0].y - hands.curPinch[n][0].y) * height,\n          //   overwrite: true,\n          //   ease: 'linear.easeNone',\n          //   immediateRender: true  \n          // })\n\n          // With this one it continuously moves based on the pinch drag distance\n          this.handsfree.TweenMax.to(this.tweenScroll[n], 1, {\n            x: this.tweenScroll[n].x - (hands.origPinch[n][0].x - hands.curPinch[n][0].x) * width * this.config.speed,\n            y: this.tweenScroll[n].y + (hands.origPinch[n][0].y - hands.curPinch[n][0].y) * height * this.config.speed,\n            overwrite: true,\n            ease: 'linear.easeNone',\n            immediateRender: true  \n          })\n\n          this.$target[n].scrollTo(this.tweenScroll[n].x, this.tweenScroll[n].y)\n        }\n      })\n    })\n  },\n\n  /**\n   * Finds the closest scroll area\n   */\n  getTarget ($potTarget) {\n    const styles = $potTarget && $potTarget.getBoundingClientRect ? getComputedStyle($potTarget) : {}\n\n    if ($potTarget && $potTarget.scrollHeight > $potTarget.clientHeight &&\n      (styles.overflow === 'auto' ||\n        styles.overflow === 'auto scroll' ||\n        styles.overflowY === 'auto' ||\n        styles.overflowY === 'auto scroll')\n    ) {\n      return $potTarget\n    } else {\n      if ($potTarget && $potTarget.parentElement) {\n        return this.getTarget($potTarget.parentElement)\n      } else {\n        return window\n      }\n    }\n  },\n\n  /**\n   * Gets the scrolltop, taking account the window object\n   */\n  getTargetScrollLeft ($target) {\n    return $target.scrollX || $target.scrollLeft || 0\n  },\n\n  /**\n   * Gets the scrolltop, taking account the window object\n   */\n  getTargetScrollTop ($target) {\n    return $target.scrollY || $target.scrollTop || 0\n  }\n}"]},"metadata":{},"sourceType":"module"}